unit TestmBitMask;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  mBitMask,
  System.Generics.Collections, System.Classes, System.SysUtils,
  DUnitX.TestFramework;

type
  // Test methods for class TBitFlag

  TestTBitMask = class
  strict private
  private
  public
    [test]
    procedure TestLoadAllowedType;
    [test]
    procedure TestLoadExceptedByObject;
    [test]
    procedure TestLoadExceptedByRecord;
    [test]
    procedure TestSizeBitCnt;
    [test]
    procedure TestByte;
  end;

implementation

uses
  Winapi.Windows;

procedure TestTBitMask.TestLoadAllowedType;
const
  LInteger : Integer  = 255;
  LCardinal: Cardinal = 255;
  LShortInt: ShortInt = 127;
  LSmallInt: SmallInt = 255;
  LLongInt : LongInt  = 255;
  LInt64   : Int64    = 255;
  LByte    : Byte     = 255;
  LWord    : Word     = 255;
  LLongWord: LongWord = 255;
  LUInt64  : UInt64   = 255;
var
  LIntegerFlag : TBitMask<Integer >;
  LCardinalFlag: TBitMask<Cardinal>;
  LShortIntFlag: TBitMask<ShortInt>;
  LSmallIntFlag: TBitMask<SmallInt>;
  LLongIntFlag : TBitMask<LongInt >;
  LInt64Flag   : TBitMask<Int64   >;
  LByteFlag    : TBitMask<Byte    >;
  LWordFlag    : TBitMask<Word    >;
  LLongWordFlag: TBitMask<LongWord>;
  LUInt64Flag  : TBitMask<UInt64  >;
begin
  Assert.WillNotRaiseAny( procedure
    begin
      LIntegerFlag.Load (LInteger );
      LCardinalFlag.Load(LCardinal);
      LShortIntFlag.Load(LShortInt);
      LSmallIntFlag.Load(LSmallInt);
      LLongIntFlag.Load (LLongInt );
      LInt64Flag.Load   (LInt64   );
      LByteFlag.Load    (LByte    );
      LWordFlag.Load    (LWord    );
      LLongWordFlag.Load(LLongWord);
      LUInt64Flag.Load  (LUInt64  );
    end);
end;

procedure TestTBitMask.TestLoadExceptedByObject;
var
  LObjFlag: TBitMask<TObject>;
begin
  Assert.WillRaise(
    procedure
    begin
      LObjFlag.Load(Self);
    end,
    ENotSupportedType);
end;

procedure TestTBitMask.TestLoadExceptedByRecord;
var
  LRecordFlag: TBitMask<TPair<Integer, Integer>>;
begin
  Assert.WillRaise(
    procedure
    begin
      LRecordFlag.Load(TPair<Integer, Integer>.Create(0, 0));
    end,
    ENotSupportedType);
end;

procedure TestTBitMask.TestSizeBitCnt;
const
  LInteger : Integer  = 255;
  LCardinal: Cardinal = 255;
  LShortInt: ShortInt = 127;
  LSmallInt: SmallInt = 255;
  LLongInt : LongInt  = 255;
  LInt64   : Int64    = 255;
  LByte    : Byte     = 255;
  LWord    : Word     = 255;
  LLongWord: LongWord = 255;
  LUInt64  : UInt64   = 255;
var
  LIntegerFlag : TBitMask<Integer >;
  LCardinalFlag: TBitMask<Cardinal>;
  LShortIntFlag: TBitMask<ShortInt>;
  LSmallIntFlag: TBitMask<SmallInt>;
  LLongIntFlag : TBitMask<LongInt >;
  LInt64Flag   : TBitMask<Int64   >;
  LByteFlag    : TBitMask<Byte    >;
  LWordFlag    : TBitMask<Word    >;
  LLongWordFlag: TBitMask<LongWord>;
  LUInt64Flag  : TBitMask<UInt64  >;
begin
  LIntegerFlag.Load (LInteger );
  LCardinalFlag.Load(LCardinal);
  LShortIntFlag.Load(LShortInt);
  LSmallIntFlag.Load(LSmallInt);
  LLongIntFlag.Load (LLongInt );
  LInt64Flag.Load   (LInt64   );
  LByteFlag.Load    (LByte    );
  LWordFlag.Load    (LWord    );
  LLongWordFlag.Load(LLongWord);
  LUInt64Flag.Load  (LUInt64  );

  Assert.AreEqual<Integer >(SizeOf(Integer ), LIntegerFlag .Size);
  Assert.AreEqual<Cardinal>(SizeOf(Cardinal), LCardinalFlag.Size);
  Assert.AreEqual<ShortInt>(SizeOf(ShortInt), LShortIntFlag.Size);
  Assert.AreEqual<SmallInt>(SizeOf(SmallInt), LSmallIntFlag.Size);
  Assert.AreEqual<LongInt >(SizeOf(LongInt ), LLongIntFlag .Size);
  Assert.AreEqual<Int64   >(SizeOf(Int64   ), LInt64Flag   .Size);
  Assert.AreEqual<Byte    >(SizeOf(Byte    ), LByteFlag    .Size);
  Assert.AreEqual<Word    >(SizeOf(Word    ), LWordFlag    .Size);
  Assert.AreEqual<LongWord>(SizeOf(LongWord), LLongWordFlag.Size);
  Assert.AreEqual<UInt64  >(SizeOf(UInt64  ), LUInt64Flag  .Size);

  Assert.AreEqual<Integer >(SizeOf(Integer ) * 8, LIntegerFlag .BitCnt);
  Assert.AreEqual<Cardinal>(SizeOf(Cardinal) * 8, LCardinalFlag.BitCnt);
  Assert.AreEqual<ShortInt>(SizeOf(ShortInt) * 8, LShortIntFlag.BitCnt);
  Assert.AreEqual<SmallInt>(SizeOf(SmallInt) * 8, LSmallIntFlag.BitCnt);
  Assert.AreEqual<LongInt >(SizeOf(LongInt ) * 8, LLongIntFlag .BitCnt);
  Assert.AreEqual<Int64   >(SizeOf(Int64   ) * 8, LInt64Flag   .BitCnt);
  Assert.AreEqual<Byte    >(SizeOf(Byte    ) * 8, LByteFlag    .BitCnt);
  Assert.AreEqual<Word    >(SizeOf(Word    ) * 8, LWordFlag    .BitCnt);
  Assert.AreEqual<LongWord>(SizeOf(LongWord) * 8, LLongWordFlag.BitCnt);
  Assert.AreEqual<UInt64  >(SizeOf(UInt64  ) * 8, LUInt64Flag  .BitCnt);
end;

procedure TestTBitMask.TestByte;
var
  LValue: TBitMask<Byte>;
begin
  LValue.Load(0);
  Assert.IsFalse(LValue[0]);
  Assert.IsFalse(LValue[1]);
  Assert.IsFalse(LValue[2]);
  Assert.IsFalse(LValue[3]);
  Assert.IsFalse(LValue[4]);
  Assert.IsFalse(LValue[5]);
  Assert.IsFalse(LValue[6]);
  Assert.IsFalse(LValue[7]);

  Assert.AreEqual(0, LValue.I[0]);
  Assert.AreEqual(0, LValue.I[1]);
  Assert.AreEqual(0, LValue.I[2]);
  Assert.AreEqual(0, LValue.I[3]);
  Assert.AreEqual(0, LValue.I[4]);
  Assert.AreEqual(0, LValue.I[5]);
  Assert.AreEqual(0, LValue.I[6]);
  Assert.AreEqual(0, LValue.I[7]);
  Assert.AreEqual('00000000', LValue.Str);

  LValue.Load(1);
  Assert.IsTrue(LValue[0]);
  Assert.IsFalse(LValue[1]);
  Assert.IsFalse(LValue[2]);
  Assert.IsFalse(LValue[3]);
  Assert.IsFalse(LValue[4]);
  Assert.IsFalse(LValue[5]);
  Assert.IsFalse(LValue[6]);
  Assert.IsFalse(LValue[7]);
  Assert.AreEqual(1, LValue.I[0]);
  Assert.AreEqual(0, LValue.I[1]);
  Assert.AreEqual(0, LValue.I[2]);
  Assert.AreEqual(0, LValue.I[3]);
  Assert.AreEqual(0, LValue.I[4]);
  Assert.AreEqual(0, LValue.I[5]);
  Assert.AreEqual(0, LValue.I[6]);
  Assert.AreEqual(0, LValue.I[7]);
  Assert.AreEqual('00000001', LValue.Str);

  LValue.Load(7);
  Assert.IsTrue(LValue[0]);
  Assert.IsTrue(LValue[1]);
  Assert.IsTrue(LValue[2]);
  Assert.IsFalse(LValue[3]);
  Assert.AreEqual(1, LValue.I[0]);
  Assert.AreEqual(1, LValue.I[1]);
  Assert.AreEqual(1, LValue.I[2]);
  Assert.AreEqual(0, LValue.I[3]);
  Assert.AreEqual(0, LValue.I[4]);
  Assert.AreEqual(0, LValue.I[5]);
  Assert.AreEqual(0, LValue.I[6]);
  Assert.AreEqual(0, LValue.I[7]);
  Assert.AreEqual('00000111', LValue.Str);

  LValue.Load(5);
  Assert.IsTrue(LValue[0]);
  Assert.IsFalse(LValue[1]);
  Assert.IsTrue(LValue[2]);
  Assert.AreEqual('00000101', LValue.Str);

  LValue.Load(128);
  Assert.IsFalse(LValue[0]);
  Assert.IsFalse(LValue[1]);
  Assert.IsFalse(LValue[2]);
  Assert.IsFalse(LValue[3]);
  Assert.IsFalse(LValue[4]);
  Assert.IsFalse(LValue[5]);
  Assert.IsFalse(LValue[6]);
  Assert.IsTrue(LValue[7]);
  Assert.AreEqual(0, LValue.I[0]);
  Assert.AreEqual(0, LValue.I[1]);
  Assert.AreEqual(0, LValue.I[2]);
  Assert.AreEqual(0, LValue.I[3]);
  Assert.AreEqual(0, LValue.I[4]);
  Assert.AreEqual(0, LValue.I[5]);
  Assert.AreEqual(0, LValue.I[6]);
  Assert.AreEqual(1, LValue.I[7]);
  Assert.AreEqual('10000000', LValue.Str);

  LValue.Load(255);
  Assert.IsTrue(LValue[0]);
  Assert.IsTrue(LValue[1]);
  Assert.IsTrue(LValue[2]);
  Assert.IsTrue(LValue[3]);
  Assert.IsTrue(LValue[4]);
  Assert.IsTrue(LValue[5]);
  Assert.IsTrue(LValue[6]);
  Assert.IsTrue(LValue[7]);
  Assert.AreEqual(1, LValue.I[0]);
  Assert.AreEqual(1, LValue.I[1]);
  Assert.AreEqual(1, LValue.I[2]);
  Assert.AreEqual(1, LValue.I[3]);
  Assert.AreEqual(1, LValue.I[4]);
  Assert.AreEqual(1, LValue.I[5]);
  Assert.AreEqual(1, LValue.I[6]);
  Assert.AreEqual(1, LValue.I[7]);
  Assert.AreEqual('11111111', LValue.Str);
end;

initialization
  // Register any test cases with the test runner
  TDUnitX.RegisterTestFixture(TestTBitMask);
end.

