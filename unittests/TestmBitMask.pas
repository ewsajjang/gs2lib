unit TestmBitMask;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  mBitMask,
  TestFramework, System.Generics.Collections, System.Classes,
  System.SysUtils;

type
  // Test methods for class TBitFlag

  TestTBitMask = class(TTestCase)
  strict private
  private
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestLoadAllowedType;
    procedure TestLoadExceptedByObject;
    procedure TestLoadExceptedByRecord;
    procedure TestSizeBitCnt;
    procedure TestByte;
  end;

implementation

uses
  Winapi.Windows;

procedure TestTBitMask.SetUp;
begin
end;

procedure TestTBitMask.TearDown;
begin
end;

procedure TestTBitMask.TestLoadAllowedType;
const
  LInteger : Integer  = 255;
  LCardinal: Cardinal = 255;
  LShortInt: ShortInt = 127;
  LSmallInt: SmallInt = 255;
  LLongInt : LongInt  = 255;
  LInt64   : Int64    = 255;
  LByte    : Byte     = 255;
  LWord    : Word     = 255;
  LLongWord: LongWord = 255;
  LUInt64  : UInt64   = 255;
var
  LIntegerFlag : TBitMask<Integer >;
  LCardinalFlag: TBitMask<Cardinal>;
  LShortIntFlag: TBitMask<ShortInt>;
  LSmallIntFlag: TBitMask<SmallInt>;
  LLongIntFlag : TBitMask<LongInt >;
  LInt64Flag   : TBitMask<Int64   >;
  LByteFlag    : TBitMask<Byte    >;
  LWordFlag    : TBitMask<Word    >;
  LLongWordFlag: TBitMask<LongWord>;
  LUInt64Flag  : TBitMask<UInt64  >;
begin
  LIntegerFlag.Load (LInteger );
  LCardinalFlag.Load(LCardinal);
  LShortIntFlag.Load(LShortInt);
  LSmallIntFlag.Load(LSmallInt);
  LLongIntFlag.Load (LLongInt );
  LInt64Flag.Load   (LInt64   );
  LByteFlag.Load    (LByte    );
  LWordFlag.Load    (LWord    );
  LLongWordFlag.Load(LLongWord);
  LUInt64Flag.Load  (LUInt64  );
end;

procedure TestTBitMask.TestLoadExceptedByObject;
var
  LObjFlag: TBitMask<TObject>;
begin
  ExpectedException := ENotSupportedType;

  LObjFlag.Load(Self);
end;

procedure TestTBitMask.TestLoadExceptedByRecord;
var
  LRecordFlag: TBitMask<TPair<Integer, Integer>>;
begin
  ExpectedException := ENotSupportedType;
  LRecordFlag.Load(TPair<Integer, Integer>.Create(0, 0));
end;

procedure TestTBitMask.TestSizeBitCnt;
const
  LInteger : Integer  = 255;
  LCardinal: Cardinal = 255;
  LShortInt: ShortInt = 127;
  LSmallInt: SmallInt = 255;
  LLongInt : LongInt  = 255;
  LInt64   : Int64    = 255;
  LByte    : Byte     = 255;
  LWord    : Word     = 255;
  LLongWord: LongWord = 255;
  LUInt64  : UInt64   = 255;
var
  LIntegerFlag : TBitMask<Integer >;
  LCardinalFlag: TBitMask<Cardinal>;
  LShortIntFlag: TBitMask<ShortInt>;
  LSmallIntFlag: TBitMask<SmallInt>;
  LLongIntFlag : TBitMask<LongInt >;
  LInt64Flag   : TBitMask<Int64   >;
  LByteFlag    : TBitMask<Byte    >;
  LWordFlag    : TBitMask<Word    >;
  LLongWordFlag: TBitMask<LongWord>;
  LUInt64Flag  : TBitMask<UInt64  >;
begin
  LIntegerFlag.Load (LInteger );
  LCardinalFlag.Load(LCardinal);
  LShortIntFlag.Load(LShortInt);
  LSmallIntFlag.Load(LSmallInt);
  LLongIntFlag.Load (LLongInt );
  LInt64Flag.Load   (LInt64   );
  LByteFlag.Load    (LByte    );
  LWordFlag.Load    (LWord    );
  LLongWordFlag.Load(LLongWord);
  LUInt64Flag.Load  (LUInt64  );

  CheckEquals(SizeOf(Integer ), LIntegerFlag .Size);
  CheckEquals(SizeOf(Cardinal), LCardinalFlag.Size);
  CheckEquals(SizeOf(ShortInt), LShortIntFlag.Size);
  CheckEquals(SizeOf(SmallInt), LSmallIntFlag.Size);
  CheckEquals(SizeOf(LongInt ), LLongIntFlag .Size);
  CheckEquals(SizeOf(Int64   ), LInt64Flag   .Size);
  CheckEquals(SizeOf(Byte    ), LByteFlag    .Size);
  CheckEquals(SizeOf(Word    ), LWordFlag    .Size);
  CheckEquals(SizeOf(LongWord), LLongWordFlag.Size);
  CheckEquals(SizeOf(UInt64  ), LUInt64Flag  .Size);

  CheckEquals(SizeOf(Integer ) * 8, LIntegerFlag .BitCnt);
  CheckEquals(SizeOf(Cardinal) * 8, LCardinalFlag.BitCnt);
  CheckEquals(SizeOf(ShortInt) * 8, LShortIntFlag.BitCnt);
  CheckEquals(SizeOf(SmallInt) * 8, LSmallIntFlag.BitCnt);
  CheckEquals(SizeOf(LongInt ) * 8, LLongIntFlag .BitCnt);
  CheckEquals(SizeOf(Int64   ) * 8, LInt64Flag   .BitCnt);
  CheckEquals(SizeOf(Byte    ) * 8, LByteFlag    .BitCnt);
  CheckEquals(SizeOf(Word    ) * 8, LWordFlag    .BitCnt);
  CheckEquals(SizeOf(LongWord) * 8, LLongWordFlag.BitCnt);
  CheckEquals(SizeOf(UInt64  ) * 8, LUInt64Flag  .BitCnt);
end;

procedure TestTBitMask.TestByte;
var
  LValue: TBitMask<Byte>;
begin
  LValue.Load(0);
  CheckFalse(LValue[0]);
  CheckFalse(LValue[1]);
  CheckFalse(LValue[2]);
  CheckFalse(LValue[3]);
  CheckFalse(LValue[4]);
  CheckFalse(LValue[5]);
  CheckFalse(LValue[6]);
  CheckFalse(LValue[7]);

  CheckEquals(0, LValue.I[0]);
  CheckEquals(0, LValue.I[1]);
  CheckEquals(0, LValue.I[2]);
  CheckEquals(0, LValue.I[3]);
  CheckEquals(0, LValue.I[4]);
  CheckEquals(0, LValue.I[5]);
  CheckEquals(0, LValue.I[6]);
  CheckEquals(0, LValue.I[7]);
  CheckEquals('00000000', LValue.Str);

  LValue.Load(1);
  CheckTrue(LValue[0]);
  CheckFalse(LValue[1]);
  CheckFalse(LValue[2]);
  CheckFalse(LValue[3]);
  CheckFalse(LValue[4]);
  CheckFalse(LValue[5]);
  CheckFalse(LValue[6]);
  CheckFalse(LValue[7]);
  CheckEquals(1, LValue.I[0]);
  CheckEquals(0, LValue.I[1]);
  CheckEquals(0, LValue.I[2]);
  CheckEquals(0, LValue.I[3]);
  CheckEquals(0, LValue.I[4]);
  CheckEquals(0, LValue.I[5]);
  CheckEquals(0, LValue.I[6]);
  CheckEquals(0, LValue.I[7]);
  CheckEquals('00000001', LValue.Str);

  LValue.Load(7);
  CheckTrue(LValue[0]);
  CheckTrue(LValue[1]);
  CheckTrue(LValue[2]);
  CheckFalse(LValue[3]);
  CheckEquals(1, LValue.I[0]);
  CheckEquals(1, LValue.I[1]);
  CheckEquals(1, LValue.I[2]);
  CheckEquals(0, LValue.I[3]);
  CheckEquals(0, LValue.I[4]);
  CheckEquals(0, LValue.I[5]);
  CheckEquals(0, LValue.I[6]);
  CheckEquals(0, LValue.I[7]);
  CheckEquals('00000111', LValue.Str);

  LValue.Load(5);
  CheckTrue(LValue[0]);
  CheckFalse(LValue[1]);
  CheckTrue(LValue[2]);
  CheckEquals('00000101', LValue.Str);

  LValue.Load(128);
  CheckFalse(LValue[0]);
  CheckFalse(LValue[1]);
  CheckFalse(LValue[2]);
  CheckFalse(LValue[3]);
  CheckFalse(LValue[4]);
  CheckFalse(LValue[5]);
  CheckFalse(LValue[6]);
  CheckTrue(LValue[7]);
  CheckEquals(0, LValue.I[0]);
  CheckEquals(0, LValue.I[1]);
  CheckEquals(0, LValue.I[2]);
  CheckEquals(0, LValue.I[3]);
  CheckEquals(0, LValue.I[4]);
  CheckEquals(0, LValue.I[5]);
  CheckEquals(0, LValue.I[6]);
  CheckEquals(1, LValue.I[7]);
  CheckEquals('10000000', LValue.Str);

  LValue.Load(255);
  CheckTrue(LValue[0]);
  CheckTrue(LValue[1]);
  CheckTrue(LValue[2]);
  CheckTrue(LValue[3]);
  CheckTrue(LValue[4]);
  CheckTrue(LValue[5]);
  CheckTrue(LValue[6]);
  CheckTrue(LValue[7]);
  CheckEquals(1, LValue.I[0]);
  CheckEquals(1, LValue.I[1]);
  CheckEquals(1, LValue.I[2]);
  CheckEquals(1, LValue.I[3]);
  CheckEquals(1, LValue.I[4]);
  CheckEquals(1, LValue.I[5]);
  CheckEquals(1, LValue.I[6]);
  CheckEquals(1, LValue.I[7]);
  CheckEquals('11111111', LValue.Str);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTBitMask.Suite);
end.

